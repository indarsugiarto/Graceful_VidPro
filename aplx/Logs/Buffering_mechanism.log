This is the strategy for output buffering.
==========================================

1. When the sendResult task is started, the root-node will trigger the chain.
2. The chain is started from block-1, because block-0 (root-node) is supposed to have its part completed.
   The root-node will broadcast MCPL_SEND_PIXELS_BLOCK with payload 1
3. The leadAp in Block-1, when receives the MCPL_SEND_PIXELS_BLOCK, will broadcast MCPL_SEND_PIXELS_BLOCK_CORES
   to all its own workers (including itself).
   3a. Each core than start streaming its own sub-block, line-by-line, to the corresponding core in root-node
       (the core with the same ID). The key to send the data is:
       MCPL_SEND_PIXELS_BLOCK_CORES_DATAxx == 0x3bxxyyyy, where xx the core-ID (so that it can be routed
                                                        correctly to the target core in root-node), and yyyy
							is the line number of the image.
       The payload is then the 4-pixels value in the current line-yyyy.
   3b. At the moment, we assume no packet drop. Hence, before sending the next line, the core must wait the
       reply from its partner core in the root-node that is supposed to send:
       MCPL_SEND_PIXELS_BLOCK_CORES_NEXTxx == 0x3fxxyyyy (and ignore the payload).
       Once the core receives this MCPL_SEND_PIXELS_BLOCK_CORES_NEXT, it can continue sending the next line.
   3c. If all lines in its part have been sent, the core sends MCPL_SEND_PIXELS_BLOCK_CORES_DONE to the leadAp
       in that chip.
   3d. The leadAp will collect MCPL_SEND_PIXELS_BLOCK_CORES_DONE from all workers. Once it collects all, the
       leadAp will send MCPL_SEND_PIXELS_BLOCK_DONE to leadAp-root.
   3e. Once the leadAp-root receives this MCPL_SEND_PIXELS_BLOCK_DONE, it increases the block counter (eq.2)
       and repeat the process step 2.
4. If the leadAp-root detects that all blocks have reported the MCPL_SEND_PIXELS_BLOCK_DONE, it starts the
   usual process of streaming data into target (host-PC or FPGA).
